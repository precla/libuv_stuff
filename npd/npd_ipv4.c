#include "npd_ipv4.h"

#define IP_LENGTH       4
#define SRC_IP_OFFSET   12
#define DEST_IP_OFFSET  (SRC_IP_OFFSET + 4)
#define HEADER_CHECKSUM 10
#define HEADER_SIZE     18                  // header without header checksum

/*
 *                    IPv4 Package format
 *  ____________________________________________________________
 * | Version |  IHL   | Type of service |     Total length      |
 * | 4 bits  | 4 bits |     1 byte      |        2 bytes        |
 * |_________|________|_________________|_______________________|
 * |           Identification           | Flags | Fragment Offs.|
 * |               2 byte               | 3 bit |    13 bits    |
 * |____________________________________|_______|_______________|
 * |         TTL      |    Protocol     |    Header checksum    |
 * |        1 byte    |     1 byte      |       2 bytes         |
 * |__________________|_________________|_______________________|
 * |                     Source IP address                      |
 * |                          4 bytes                           |
 * |____________________________________________________________|
 * |                  Destination IP address                    |
 * |                          4 bytes                           |
 * |____________________________________________________________|
 * |                    Options             |     Padding       |
 * |                 variable size          |   variable size   |
 * |________________________________________|___________________|
 */

void print_ipv4_data(char *ipv4packet, size_t size) {
    printf("\n\n%20s\t%lu bytes", "L3 IPv4 packet size:", size);

    uChar ipv4srcadr[4] = {0};
    uChar ipv4destadr[4] = {0};
    uChar ipv4h[HEADER_SIZE];     // header without header checksum
    uInt crcread, crccalc = 0;

    ipv4_address(ipv4packet + SRC_IP_OFFSET, ipv4srcadr);
    ipv4_address(ipv4packet + DEST_IP_OFFSET, ipv4destadr);
    ipv4_header(ipv4packet, ipv4h);

    printf("\n%20s\t", "IPv4 source address:");
    print_ipv4_address(ipv4srcadr);
    printf("\n%20s\t", "IPv4 dest. address:");
    print_ipv4_address(ipv4destadr);

    crcread = ipv4_checksum((uChar *)(ipv4packet + HEADER_CHECKSUM));
    crccalc = calc_ipv4_header_checksum(ipv4h);

    printf("\n%20s\t0x%x", "checksum read:", crcread);
    printf("\n%20s\t0x%x", "checksum calculated:", crccalc);
    if (crccalc != crcread) {
        printf("\n%20s\t%s\n", "CRC:", "Mismatch!");
    } else {
        printf("\n%20s\t%s\n", "CRC:", "Match!");
    }
}

char *ipv4_data_within_packet(char *packet, size_t packetsize) {
    char *ipv4packet = calloc(sizeof(char), packetsize);
    if (!ipv4packet) {
        printf("\ncalloc() for ipv4packet returned NULL. No free memory?");
        return NULL;
    }
    memcpy(ipv4packet, packet, packetsize);
    return ipv4packet;
}

void ipv4_address(char *ipv4packet, uChar *dest) {
    memcpy(dest, ipv4packet, IP_LENGTH);
    for (uShort i = 0; i < IP_LENGTH; ++i) {
        dest[i] = (uShort)dest[i];
    }
}

void ipv4_header(char *p, uChar *h) {
    memcpy(h, p, 10);
    // move header by 10 bytes, to not overwrite prev memcpy
    // and move packet by 12 bytes to skip header checksum
    memcpy(h + 10, p + 12, 8);
}

/*
 * take two bytes and save them into tmp
 * whenever the 2nd bytes has been set, do sum
 * https://en.wikipedia.org/wiki/IPv4_header_checksum#Calculating_the_IPv4_header_checksum
 */
uInt calc_ipv4_header_checksum(uChar *h) {
    uInt hsum = 0;
    uInt tmp = 0;
    for (int i = 0; i < HEADER_SIZE; i++) {
        if (i % 2 == 1) {
            tmp ^= h[i];
            hsum += tmp;
        } else {
            tmp = h[i];
            tmp <<= 8;
        }
    }

    // The first digit is the carry count and is added to the sum
    // always move right by 4 bits and check the next 4 bits if zero or not
    // as long as those ar not zero, move once more by 4 bits
    tmp = hsum;
    uInt bytes = sizeof(uLong);
    uInt tmp2 = 0;
    for (int i = 0; i < bytes; i++) {
        tmp >>= 4;
        if ((tmp >> 4) == 0) {
            tmp2 = tmp;
            tmp = 0 | (tmp << ((++i) * 4));
            hsum ^= tmp;
            hsum += tmp2;
            break;
        }
    }

    // if another carry is generated by the prev addition, another 1 must be added to the sum
    if ((hsum >> 16) > 0) {
        hsum += 1;
    }

    return ~hsum & 0xFFFF;
}

void print_ipv4_address(uChar *ipv4addr) {
    for(uShort i = 0; i < IP_LENGTH; ++i) {
        printf("%u", ipv4addr[i]);
        if(i < (IP_LENGTH - 1)) {
            printf(".");
        }
    }
}

uInt ipv4_checksum(uChar *ipv4packet) {
    return ( (ipv4packet[0] << 8) | ipv4packet[1] );
}
